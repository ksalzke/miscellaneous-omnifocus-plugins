/*{
	"type": "library",
	"targets": ["omnifocus"],
	"identifier": "com.KaitlinSalzke.functionLibrary",
	"version": "1.0"
}*/
var _ = (function() {
  var functionLibrary = new PlugIn.Library(new Version("1.0"));

  config = PlugIn.find("com.KaitlinSalzke.config").library("configLibrary");

  functionLibrary.findTag = function(nameToFind) {
    var targetTag = null;
    tags.apply(function(tag) {
      if (tag.name == nameToFind) {
        targetTag = tag;
        return ApplyResult.Stop;
      }
    });
    return targetTag;
  };

  functionLibrary.getRootTask = function(childTask) {
    rootTask = null;
    index = 0;
    tasksToCheck = childTask.containingProject.task.children;
    while (rootTask === null && index < tasksToCheck.length) {
      tasksToCheck[index].apply(function(task) {
        if (task == childTask) {
          rootTask = tasksToCheck[index];
          return ApplyResult.Stop;
        }
      });
      index++;
    }
    return rootTask;
  };

  functionLibrary.removeProjectTagsFromTasks = function(taskArray) {
    taskArray.forEach(task => {
      //check if this is a project; if not remove tags
      if (
        task.project == null &&
        !config
          .projectsWhereProjectTagsAllowed()
          .includes(task.containingProject)
      ) {
        task.removeTags(config.projectTags());
      }
    });
  };

  functionLibrary.getAllRemainingTasks = function() {
    allTasks = [];
    library.apply(function(item) {
      if (
        item instanceof Project &&
        (item.status == Project.Status.Active ||
          item.status == Project.Status.OnHold) &&
        item.task.hasChildren
      ) {
        item.task.children.forEach(tsk => {
          if (
            tsk.taskStatus !== Task.Status.Dropped &&
            tsk.taskStatus !== Task.Status.Completed
          ) {
            allTasks.push(tsk);
          }
        });
      }
    });
    return allTasks;
  };

  functionLibrary.getTaskWithId = function(taskId, tagToSearch) {
    foundTask = null;
    i = 0;
    while (foundTask == null && i < tagToSearch.tasks.length) {
      if (tagToSearch.tasks[i].id.primaryKey == taskId) {
        return tagToSearch.tasks[i];
      }
      i++;
    }
  };

  // this doesn't seem to be working - not sure why.
  functionLibrary.replaceTag = function(tasksArray, oldTag, newTag) {
    tasksArray.forEach(function(task) {
      task.addTag(oldTag);
      task.removeTag(newTag);
    });
  };

  return functionLibrary;
})();
_;
